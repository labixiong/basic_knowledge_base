# typescript 基础部分

默认情况下 ts会做出如下假设：
1. 假设当前执行环境是dom
2. 如果代码中没有使用模块化语句（import、export），便认为该代码是全局执行
3. 编译的目标代码是es3

有两种方式可以改变以上假设
1. 使用tsc命令行的时候，加上选项参数
2. 使用ts配置文件，更改编译选项 使用tsc --init命令生成配置文件

## ts的配置文件

使用了配置文件后，使用tsc进行编译时，不能跟上文件名，如果跟上文件名，会忽略配置文件

@types/node

## 使用第三方库简化流程

ts-node：将ts代码在内存中完成编译，同时完成运行

nodemon: 检测文件变化

## 基本类型约束

TS是一个可选的静态的类型系统

- number: 数字
- string：字符串
- boolean：布尔
- 数组
- object：对象
- null和undefined

null和undefined是所有类型的子类型，它们可以赋值给其他类型

通过改变配置文件中 strictNullChecks 为 true，即可获得更严格的空类型检查，null和undefined只能赋值给自身

## 其他类型

- 联合类型
- void类型 通常用于约束函数的返回值，表示该函数没有返回
- never类型 通常用于约束函数的返回值，表示该函数永远不可能结束
- 字面量类型 使用一个值进行约束
- 元组类型（Tuple）一个固定长度的数组，并且数组中每一项的类型确定
- any类型 会绕过类型检查

## 类型别名

## 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明

可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递,可选参数必须在参数列表的末尾

## 扩展类型 - 枚举

枚举通常用于某个变量的取值范围

字面量和联合类型配合使用，也可以达到同样的目标。

**字面量类型的问题**

- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题
- 逻辑含义和真实的值产生了混淆，会导致当修改真实值的时候，产生大量的修改
- 字面量类型不会进入到编译结果

**枚举**

枚举会出现在编译结果中，编译结果中表现为对象

```ts
// 编译前
// src/index.ts
enum Gender {
  male = '男',
  female = '女'
}
let gender: Gender
gender = Gender.male
gender = Gender.female
```

```js
// 编译后
// dist/index.js
var Gender;
(function (Gender) {
    Gender["male"] = "\u7537";
    Gender["female"] = "\u5973";
})(Gender || (Gender = {}));
let gender;
gender = Gender.male;
gender = Gender.female;
```

### 枚举的规则

- 枚举的字段值可以是字符串或数字
- 数字枚举值会自增
- 被数字枚举约束的变量，可以直接赋值为数字
- 数字枚举的编译结果和字符串枚举有差异

### 最佳实践

- 尽量不要在一个枚举中既出现数字字段又出现字符串字段
- 使用枚举时，尽量使用枚举字段的名称，而不使用真实的值


### 枚举的位运算

两个数字换算成二进制后进行的运算

---

## 编译结果中的模块化


|      配置名称       |              含义              |
| :-----------------: | :----------------------------: |
|       module        | 设置编译结果中使用的模块化标准 |
|  moduleResolution   |       设置解析模块的模式       |
| noImplicitUseStrict |  编译结果中不包含"use strict"  |
|   removeComments    |        编译结果移除注释        |
|    noEmitOnError    |      错误时不生成编译结果      |
|   esModuleInterop   |  启用es模块化交互非es模块导出  |

ts中模块化的编译结果中：

- 如果编译结果的模块化标准是es6，则没有变化
- 如果编译结果的模块化标准是commonjs：导出的声明会变成exposts属性，默认的导出会变成exports的default属性

如何在ts中使用commonjs模块化导入导出？

其实是可以使用commonjs模块化进行导入导出的，只不过会丢失语法提示和类型检查等

可以使用以下方式
```js
// 导出module
export = {
  name: 'kevin'
}

// 导入module
import module  = require('./module')
```

## 模块解析

应该从什么位置寻找模块？

ts中有两种模块解析策略

- classic
- node解析策略，唯一的变化就是将js替换为ts

一般使用node解析策略，避免出问题，moduleResolution 配置设置为true


## 接口

可以通过接口之间的继承，实现多种接口的组合

使用类型别名可以实现类似的组合效果，需要通过 & 来连接，实现交叉类型

区别：
- 子接口不能重写父接口中的成员
- 交叉类型会把相同成员的类型进行交叉

**readonly** -- 只读修饰符，保证属性不可被更改，不出现在编译结果中

## 类型兼容性

- 基本类型 完全匹配

- 对象类型 鸭子匹配 目标类型需要某一些特征，赋值的类型只要能满足该特征即可

- 函数类型
  
    参数：传递给目标函数的参数可以少，但不可以多

    返回值：要求返回必须返回；不要求返回，你随意；


## 类

**`src/class.ts`**

- 属性

使用属性列表来描述类中的属性

- 属性的初始化检查

配置`strictPropertyInitialization: true`

1. 构造函数中需要初始化
2. 属性的默认值

- 属性可以修饰为可选的
- 属性可以修饰为只读的
- 使用访问修饰符可以控制类中成员的访问权限

  1. public 默认值 公开访问
  2. private 私有的 只有类内部可以使用
  3. protected 受保护的

- 属性简写 见类构造器中的name和age属性
- 访问器 用于控制属性的读取和赋值 get set

