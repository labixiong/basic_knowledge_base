# ts进阶 {ignore=true}

[toc]

## 面向对象概述

## 类

### 抽象类

有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类

给类前面加上 `abstract`, 表示该类是一个抽象类，无法创建实例对象，只能被别的类继承

### 抽象成员

父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或者实现是什么。因此需要一个强约束，让继承该类的子类必须要实现该成员

抽象类中可以有抽象成员，抽象成员只能出现在抽象类中，这些抽象成员必须在子类中实现

### 设计模式 - 模板模式

设计模式：面对一些常见的功能场景，有一些固定的，经过多年实践的成熟方法，这些方法称之为设计模式

模板模式：有些方法，所有的子类实现的流程完全一致，只是流程中的某个步骤的具体实现不一致，可以将该方法提取到父类，在父类中完成整个流程和实现，遇到实现不一致的方法时，将该方法作为抽象方法交由子类去实现


## 静态成员

静态成员是指附着在类上的成员 使用static关键字修饰

静态方法中的this指向的是当前类，实例方法中的this指向当前对象

## 设计模式 - 单例模式

单例模式:某些类的对象,在系统中最多只能有一个,为了避免开发者造成随意创建多个类对象的错误,可以使用单例模式进行强约束


## 接口

`animals.ts`

与类联用时,类继承接口时,表示某个类是否拥有某种能力

接口和类型别名的最大区别:接口可以被类实现,而类型别名不可以

接口可以继承类,表示该类的所有成员都在接口中

## 索引器

`对象[key]` 使用成员表达式

在ts中，默认不对索引器（成员表达式）做类型检查, 可以使用配置 `noImplicitAny` 设置为true，开启对索引器的检查

如果要使用未知的属性可以使用定义索引器的方式

在索引器中，键的类型可以是字符串也可以是数字， **索引器书写的位置是所有成员的最上方**

```ts
class Index {
  // 定义索引器，这时候如果输出未定义属性就可以使用了，因为prop定义了所有类型的属性
  [prop: string]: any
  constructor(
    public name: string,
    public age: number
  ) { }

  sayHello() { }
}

const i = new Index('zs', 18)

// 下面的输出会报错
// 元素隐式具有 "any" 类型，因为类型为 ""id"" 的表达式不能用于索引类型 "Index"。类型“Index”上不存在属性“id”。
console.log(i['id']);
```

ts中索引器的作用：

- 在严格的类型检查下，可以实现为类动态增加成员
- 可以实现动态的操作类成员

在JS中，所有的成员本质上都是字符串，如果使用数字作为成员名，也会自动转换为字符串

在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值的类型必须匹配

```ts
class B { }

class A {
  // 此时前后两种索引器的值的类型必须匹配
  // 也可以不一样，但是两种类型必须是后方的子类型或者相同类型
  // 例如将第一个索引器的值约束为类B，那么第二个索引器的类型也必须约束为B或者是B的父类型，例如object
  // 如果第一个的值约束为string，那么第二个也要约束为string或者string的父类型，例如object
  [prop: number]: string
  [prop: string]: string
}

const a = new A()
a[0] = 'gsdg'
a['asdgsd'] = 'gsdg'

console.log(a);
```



## this指向约束

> [this指向文章参考](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)

### JS中this指向的集中情况

this指向大部分时候取决于函数调用方式

- 直接调用函数（全局调用），this指向全局对象或者undefined（当启用严格模式时）
- 使用`对象.方法`，则this指向对象本身
- 如果是dom事件的处理函数，this指向事件处理对象

特殊情况：
1. 箭头函数，this是在函数声明时确定指向，指向函数所在位置的this
2. 使用bind、apply、call手动绑定this对象


### TS中的this

配置noImplicitThis设置为true，表示不允许this隐式的指向any

在TS中允许在书写函数时，手动声明该函数中this的指向（将this作为函数的第一个参数），该参数只用于约束this，并不是真正的参数，如果函数有参数，依次书写即可，也不会真正的出现在编译结果中