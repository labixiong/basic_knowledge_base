# ts进阶 {ignore=true}

[TOC]

## 面向对象概述

## 类

### 抽象类

有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类

给类前面加上 `abstract`, 表示该类是一个抽象类，无法创建实例对象，只能被别的类继承

### 抽象成员

父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或者实现是什么。因此需要一个强约束，让继承该类的子类必须要实现该成员

抽象类中可以有抽象成员，抽象成员只能出现在抽象类中，这些抽象成员必须在子类中实现

### 设计模式 - 模板模式

设计模式：面对一些常见的功能场景，有一些固定的，经过多年实践的成熟方法，这些方法称之为设计模式

模板模式：有些方法，所有的子类实现的流程完全一致，只是流程中的某个步骤的具体实现不一致，可以将该方法提取到父类，在父类中完成整个流程和实现，遇到实现不一致的方法时，将该方法作为抽象方法交由子类去实现


## 静态成员

静态成员是指附着在类上的成员 使用static关键字修饰

静态方法中的this指向的是当前类，实例方法中的this指向当前对象

## 设计模式 - 单例模式

单例模式:某些类的对象,在系统中最多只能有一个,为了避免开发者造成随意创建多个类对象的错误,可以使用单例模式进行强约束


## 接口

`animals.ts`

与类联用时,类继承接口时,表示某个类是否拥有某种能力

接口和类型别名的最大区别:接口可以被类实现,而类型别名不可以

接口可以继承类,表示该类的所有成员都在接口中

## 索引器

`对象[key]` 使用成员表达式

在ts中，默认不对索引器（成员表达式）做类型检查, 可以使用配置 `noImplicitAny` 设置为true，开启对索引器的检查

如果要使用未知的属性可以使用定义索引器的方式

在索引器中，键的类型可以是字符串也可以是数字， **索引器书写的位置是所有成员的最上方**

```ts
class Index {
  // 定义索引器，这时候如果输出未定义属性就可以使用了，因为prop定义了所有类型的属性
  [prop: string]: any
  constructor(
    public name: string,
    public age: number
  ) { }

  sayHello() { }
}

const i = new Index('zs', 18)

// 下面的输出会报错
// 元素隐式具有 "any" 类型，因为类型为 ""id"" 的表达式不能用于索引类型 "Index"。类型“Index”上不存在属性“id”。
console.log(i['id']);
```

ts中索引器的作用：

- 在严格的类型检查下，可以实现为类动态增加成员
- 可以实现动态的操作类成员

在JS中，所有的成员本质上都是字符串，如果使用数字作为成员名，也会自动转换为字符串

在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值的类型必须匹配

```ts
class B { }

class A {
  // 此时前后两种索引器的值的类型必须匹配
  // 也可以不一样，但是两种类型必须是后方的子类型或者相同类型
  // 例如将第一个索引器的值约束为类B，那么第二个索引器的类型也必须约束为B或者是B的父类型，例如object
  // 如果第一个的值约束为string，那么第二个也要约束为string或者string的父类型，例如object
  [prop: number]: string
  [prop: string]: string
}

const a = new A()
a[0] = 'gsdg'
a['asdgsd'] = 'gsdg'

console.log(a);
```



## this指向约束

> [this指向文章参考](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)

### JS中this指向的集中情况

this指向大部分时候取决于函数调用方式

- 直接调用函数（全局调用），this指向全局对象或者undefined（当启用严格模式时）
- 使用`对象.方法`，则this指向对象本身
- 如果是dom事件的处理函数，this指向事件处理对象

特殊情况：
1. 箭头函数，this是在函数声明时确定指向，指向函数所在位置的this
2. 使用bind、apply、call手动绑定this对象


### TS中的this

配置noImplicitThis设置为true，表示不允许this隐式的指向any

在TS中允许在书写函数时，手动声明该函数中this的指向（将this作为函数的第一个参数），该参数只用于约束this，并不是真正的参数，如果函数有参数，依次书写即可，也不会真正的出现在编译结果中

### 装饰器

实际上就是一个函数，用来描述数据的数据，可以理解为元数据

解决的问题： 

装饰器，能够带来额外的信息量，可以达到分离关注点的目的。

- 信息书写位置的问题
- 重复代码的问题

上述两个问题产生的根源：某些信息，在定义时，能够附加的信息量有限。

装饰器的作用：为某些属性、类、参数、方法提供元数据信息(metadata)

元数据：描述数据的数据

本质：

在JS中，装饰器是一个函数。（装饰器是要参与运行的）

装饰器可以修饰：

- 类
- 成员（属性+方法）
- 参数

#### 类装饰器

类装饰器的本质是一个函数，该函数接收一个参数，表示类本身（构造函数本身）

使用装饰器 @得到一个函数

在TS中，如何约束一个变量为类

- Function 类的本质就是一个函数
- ```new (参数) => object``` 代表一个可以创建实例的函数

装饰器函数的运行时间： 在类定义后直接运行

类装饰器可以具有返回值：

- void：仅运行函数
- 返回一个新的类：会将新的类替换掉装饰目标

多个装饰器的情况：会按照后加入先调用的顺序调用（倒序）


#### 成员装饰器

- 属性

属性装饰器也是一个函数，该函数需要两个参数：

1. 如果是静态属性，则为类本身；如果是实例属性，则为类的原型
2. 固定为一个字符串，表示属性名

- 方法

方法装饰器也是一个函数，该函数需要三个参数

1. 如果是静态方法，则为类本身；如果是实例方法，则为类的原型
2. 固定为一个字符串，表示方法名
3. 属性描述对象  （读、写、枚举）

可以有多个装饰器装饰

### reflect-metadata

保存元数据

### class-validator和class-transformer

class-validator 类型验证

class-transformer 类型转换，将一个json数据转换为一个类对象以使用类的方法

### 补充

1. 参数装饰器

2. 关于TS自动注入的元数据

3. AOP

## 类型演算

根据已知信息，计算出新的类型

### 三个关键字

> src/keywords.ts

- typeof

TS中的typeof，书写的位置在类型约束的位置上

表示获取某个数据的类型

当typeof作用于类的时候，得到的类型是该类的构造函数 等同于 ```new (...args: any[]) => object```

- keyof

作用于类、接口、类型别名，用于获取其他类型中的所有成员组成的联合类型

- in

该关键字往往和keyof联用，限制某个索引类型的取值范围

### 预定义的类型演算

- Required<T> 必填 -? 为去除那些可选的属性

```js
type Required<T> = {
  [p in keyof T]-?: T[p]
}
```

- Exclude<T> 

```js
type Exclude<T, U> = T extends U ? never : T 
```

- Extract<T>

```js
type Exclude<T, U> = T extends U ? T : never
```

- NonNullable<T> 从T中去除null和undefined

类型断言 n! 只能去除undefined

```js
let str = string | null | undefined

type StrNonNullable = NonNullable<str>
```

- ReturnType<T> 拿到函数的返回值类型

```js
let func: () => number

type returnType = ReturnType<typeof func>

// ReturnType<typeof func> 这里typeof func代表传入的是func的类型
// 也可以定义的时候直接用type进行定义

type func = () => number
```

- InstanceType<T> 获取构造函数类型的实例类型


## 声明文件

### 概述

以```.d.ts```为结尾的文件就是声明文件

**作用：**

有的时候写的代码不是ts写的，比如用js写的代码，后期使用ts改造，如何兼容呢？

js里面有哪些类型ts不知道，ts就可以使用声明文件为js代码提供类型声明

**声明文件的位置：**

- 放置到tsconfig.json配置中包含的目录中
- 放置到node_modules/@types文件夹中
- 手动配置，在tsconfig.json文件中使用typeRoots配置指定声明文件所在目录 此配置会让前面两个条件都失效
- 与js代码所在目录相同并且文件名也相同的文件。用ts代码书写的工程发布之后的格式

### 编写

### 发布


